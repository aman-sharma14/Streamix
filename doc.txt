Network Security & Information Technologies ESE Report


Streamix - Movie Streaming Laptop 
(Deployment & Pentesting)



Project Report: Streamix – Secure Distributed Microservices Architecture
1. Project Overview
1.1 Introduction
Streamix is an enterprise-grade movie streaming and metadata management platform built using a microservices architectural pattern. The core objective of the project is to provide a seamless user experience for discovering, tracking, and viewing cinema content while maintaining a highly decoupled and scalable backend. Unlike monolithic applications, Streamix separates its business logic into specialized services that communicate over a virtual network, allowing for independent scaling and maintenance of specific features such as user authentication, movie catalogs, and social interactions.
1.2 System Architecture and Component Breakdown
The system is composed of five primary backend components and a modern frontend interface:
Netflix Eureka Discovery Server: This acts as the "Service Registry." In a dynamic microservice environment, instances can start and stop on different IP addresses. Eureka allows all services to find each other by name rather than hardcoded addresses, ensuring high availability.
Spring Cloud API Gateway: Acting as the single point of entry for the entire ecosystem, the Gateway handles all routing logic. It centralizes cross-cutting concerns such as security filtering, CORS configuration, and rate limiting, preventing the need to implement these features in every individual microservice.
Identity Service: This is the security hub of the application. It manages the user lifecycle, including registration, secure credential storage, and the issuance of cryptographic identity tokens (JWT).
Catalog Service: Responsible for the movie and TV series library. It features a hybrid data ingestion logic that queries a local PostgreSQL database for speed and falls back to external APIs (TMDB/OMDB) to provide an "infinite" library experience.
Interaction Service: This service handles user-specific stateful data. It manages "Watchlists" and "Watch History," including the persistence of timestamps to allow users to resume playback from where they last stopped.
React Frontend: A responsive Single Page Application (SPA) that communicates with the backend via the API Gateway using secure HTTPS protocols.

1.3 Problem Statement and Motivation
Modern web applications face two primary challenges: scalability and security. Traditional monolithic architectures become "bottlenecks" as the user base grows. Furthermore, standard implementations of authentication often suffer from vulnerabilities such as session hijacking, brute-force attacks, and data sniffing.
Streamix was developed to demonstrate how these challenges can be mitigated using:
Microservices to prevent a single point of failure in business logic.
Defense in Depth security strategies to protect user data at the network, application, and session layers.
1.4 Core Technology Stack
Framework: Spring Boot 3.4.2 (LTS) providing the foundation for microservices.
Language: Java 21, utilizing modern features like record types and enhanced concurrency.
Security: Spring Security 6.x and JSON Web Tokens (JWT).
Data Layer: PostgreSQL (via Supabase) for relational data and Redis (via Upstash) for stateful session caching, OTP staging, and rate-limiting counters.
Messaging: RESTful API communication enriched with Spring Cloud OpenFeign for inter-service calls.
Deployment & Infrastructure: Render PaaS for global application hosting, utilizing Cloudflare CDN for DDoS protection and edge routing.



2. Identity Service: Security Architecture
The Identity Service has been hardened to meet industry standards for authentication and data integrity.
2.1 Verified Registration Workflow
To prevent database bloat and mitigate bot-driven account creation, the system implements a two-stage registration process:
Staging Phase: User details are validated and temporarily stored in a Redis cache instead of the primary database.
Challenge-Response: A cryptographically secure 6-digit OTP is generated and dispatched to the user via SMTP.
Persistence: The registration is finalized only upon successful verification of the OTP. Redis entries are configured with a 15-minute Time-To-Live (TTL), ensuring automatic cleanup of unverified data.
2.2 Input Sanitation and Validation
The service implements multi-layered defense against injection and impersonation:
Invisible Character Defense: Specialized Regular Expressions (\p{Cf}) are utilized to strip invisible Unicode characters (e.g., U+200E). This prevents attackers from bypassing unique constraint checks or creating deceptive usernames.
DTO Enforcement: All API inputs are strictly validated using Jakarta Validation (Hibernate Validator). Request objects (DTOs) enforce strict constraints on field lengths, patterns, and mandatory fields before the data reaches the business logic layer.
2.3 Cryptography and Token Management
Secure Hashing: Passwords are never stored in plain text. The system employs BCrypt with a work factor of 10 to ensure high resistance against brute-force and rainbow table attacks.
Stateless Authorization: Identity is maintained via short-lived JSON Web Tokens (JWT). This architecture ensures that microservices can verify user identity without querying a central database for every request.
Concurrency Control: A sliding-window refresh token mechanism is implemented via Redis. To prevent account sharing and unauthorized access, the system enforces a strict limit of 5 concurrent active sessions per user account.
2.4 Database and Network Security
SQL Injection Prevention: All interactions with the PostgreSQL (Supabase) database are handled through Spring Data JPA's parameterized queries, neutralizing SQL injection vectors.
Zero-Trust Internal Network: While external traffic is routed through the API Gateway, internal microservice communication is restricted. Due to free-tier cloud constraints preventing VPC isolation, the architecture enforces a custom Application-Level Zero-Trust Firewall. The Gateway injects a cryptographic X-Internal-Secret header into all valid traffic, which downstream microservices (Identity, Catalog, Interaction) strictly validate via a Spring OncePerRequestFilter, dropping any direct internet connections with a 403 Forbidden.
Discovery Server Hardening: The Eureka Server dashboard is secured from unauthorized access and network mapping utilizing Spring Security and HTTP Basic Authentication.



3. API Gateway: Distributed Rate Limiting
To safeguard the infrastructure against Brute-Force and Distributed Denial of Service (DDoS) attacks, the API Gateway implements a distributed rate-limiting strategy.
3.1 Distributed vs. Local Rate Limiting
The platform utilizes a Distributed Rate Limiting approach powered by Redis, rather than a local in-memory solution. In a multi-instance microservices environment, local rate limiting can be bypassed by distributing traffic across different gateway nodes. By centralizing the request counters in Upstash Redis, all gateway instances synchronize their state, ensuring that a single attacker cannot circumvent limits by rotating between different entry points.
3.2 Token Bucket Algorithm
The system employs the Token Bucket algorithm, which balances strict traffic control with the flexibility to handle legitimate usage bursts:
Imagine each user has a bucket of tokens.
Tokens are added at a fixed rate.
Each request must take 1 token.
If the bucket is empty → request is rejected.

Replenish Rate (10/s): Defines the steady-state speed limit, allowing for 10 requests per second under normal conditions.
Burst Capacity (20): Allows for transient traffic spikes by permitting up to 20 requests in a rapid burst before the bucket is depleted.
Requested Tokens (1): Each inbound request consumes exactly one token from the bucket.
3.3 Zero-Trust Rate Limiting Perimeter
The security perimeter extends beyond public endpoints to encompass the entire internal microservices ecosystem. This "Zero-Trust" architecture ensures that even authenticated users are subject to traffic monitoring and control:
Public Defense: Protects the /auth/** routes to prevent credential stuffing and registration spam.
Private Defense: Rate limiters are positioned after the AuthenticationFilter for internal routes (/movie/**, /tv/**, /interaction/**). This prevents authenticated users from executing malicious scraping scripts or overwhelming downstream databases.
IP-Based Identification: A custom KeyResolver utilizes the client's host IP address as the unique identifier for each bucket. This ensures that rate limits are enforced at the network level, independent of user account status. Thus even if users create multiple accounts, the IP limit still applies.
Upon exceeding the configured limits, the Gateway intercepts the request and returns an HTTP 429 (Too Many Requests) status code, shielding downstream services from the traffic spike.


4. JWT & Session Management
The platform implements a hybrid authentication model that combines stateless security for high-performance request validation with stateful session management for granular control and multi-device support.
4.1 Stateless Access Tokens (JWT)
To minimize the impact of token theft, the system utilizes short-lived JSON Web Tokens (JWT) for all authenticated requests:
Aggressive Expiration: Access tokens are configured with a 15-minute lifespan. This "window of vulnerability" ensures that any compromised token becomes useless within a short timeframe.
Centralized Validation: The API Gateway intercepts all requests to secured routes. It validates the JWT signature locally using cryptographic keys, avoiding expensive network calls to the Identity Service for every request.
Identity Propagation: Upon successful validation, the Gateway extracts the user's identity (email) and injects it into the X-User-Email HTTP header. Downstream microservices explicitly trust this header, simplifying their internal logic and maintaining a Zero-Trust architecture.
4.2 Stateful Refresh Tokens (UUID)
Long-term session persistence is managed through revokable Refresh Tokens:
Opaque UUIDs: Unlike access tokens, refresh tokens are securely generated UUIDs stored in Redis. This ensures that refresh tokens carry no intrinsic data and can be instantly revoked by deleting the Redis mapping.
7-Day TTL: Refresh tokens have a 7-day Time-To-Live, allowing for a seamless user experience while ensuring that inactive sessions are periodically purged.
Silent Renewal: The frontend implements interceptors to catch 401 Unauthorized errors. When an access token expires, the system automatically uses the refresh token to negotiate a new access token in the background, ensuring zero interruption for the user.
4.3 Multi-Device Session Control (FIFO Queue)
Streamix implements enterprise-grade session orchestration to prevent account sharing while maintaining a premium user experience.
Distributed Session Tracking: Active session IDs are maintained in a Redis List specific to each user (USER_SESSIONS_{email}).
FIFO Enforcement: The system enforces a 5-device limit per account. When a user logs in on a 6th device, the AuthService performs an atomic First-In-First-Out (FIFO) purge.
Automatic Revocation: The oldest session UUID is popped from the list and its mapping is deleted from Redis. This instantly invalidates the oldest device's session without impacting the user's latest login.
This architecture provides a robust defense-in-depth strategy, balancing stateless performance with stateful security and strict resource control.


5. Secure Logout & Session Invalidation
To mitigate the risk of "Ghost Sessions"—where a user has logged out locally but their session remains active on the server—Streamix implements a synchronized server-side invalidation flow.
5.1 The Security Flaw of Stateless Logout
In traditional JWT-only architectures, logging out is often a purely client-side action (deleting the token from local storage). However, if a refresh token is stolen prior to logout, it remains valid on the server until its natural expiration. This creates a significant security gap and can lead to "stuck" sessions that consume the user's allocated device slots.
5.2 Synchronized Invalidation Mechanism
The platform resolves this by facilitating a multi-step destruction process triggered by the user's logout action:
API Invalidation Hook: Upon clicking "Sign Out," the React frontend issues an asynchronous POST request to the /auth/logout endpoint before clearing local storage.
Atomic Redis Deletion: The AuthService executes two critical operations:
Token Mapping Removal: The refresh token UUID is deleted from Redis, ensuring any subsequent attempt to use it results in an immediate 401 Unauthorized.
Slot Reclamation: The specific token is removed from the USER_SESSIONS_{email} list, instantly freeing up a device slot for the user.
Frontend State Purge: Once the backend confirms invalidation, the frontend clears all tokens and triggers a hard window reload. This ensures that sensitive state variables (e.g., watchlists, profile metadata) are garbage-collected and not accessible to subsequent users on the same device.
5.3 Security Benefits
Session Perfect Forward Secrecy: Ensures that a stolen session identifier becomes worthless the moment a legitimate logout occurs.
Accurate Resource Tracking: Maintains the integrity of the 5-device limit by ensuring only truly active sessions consume capacity.
Memory Integrity: Prevents cross-session data leakage within the browser environment.




6. API Gateway: Security Headers
To protect the platform against browser-based exploitation, the API Gateway implements a centralized SecurityHeadersFilter. This global filter ensures that every response from the microservices ecosystem is accompanied by strict instructions that harden the browser's security posture.
6.1 Defensive Header Configurations
The following headers are programmatically attached to all outbound responses:
HTTP Strict Transport Security (HSTS): 
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload.
HSTS enforces the exclusive use of HTTPS connections for all subdomains over a one-year period. This prevents SSL-stripping and network-level man-in-the-middle (MitM) attacks, ensuring that browsers automatically upgrade any insecure HTTP requests to secure HTTPS.
X-Content-Type-Options: nosniff.
This header instructs browsers to strictly adhere to the server-specified Content-Type for all responses, preventing MIME-type sniffing attacks. It mitigates the risk of malicious scripts being executed from files misclassified as safe content, enhancing protection against drive-by downloads.
X-Frame-Options: DENY. 
By disallowing the rendering of Streamix within <iframe>, <frame>, or <object> elements on any domain, this header provides absolute protection against clickjacking attacks. It prevents attackers from overlaying invisible interfaces that trick users into performing unintended actions.
Content-Security-Policy (CSP):
default-src 'none'; frame-ancestors 'none'; sandbox
AGiven that the platform primarily serves JSON APIs, the CSP is configured to be maximally restrictive. It disallows execution of scripts, loading of images, and fetching of stylesheets, while prohibiting framing. This effectively neutralizes the execution of any injected Cross-Site Scripting (XSS) payloads.(XSS) payloads at the API level.
X-XSS-Protection: 1; mode=block
This legacy header instructs older browsers to block pages upon detecting XSS attempts, providing an additional fallback layer of protection.
6.2 Implementation Verification
Applying these headers at the Gateway ensures:
Consistency: Every response leaving the platform adheres to the same security policies.
Operational simplicity: Individual microservices do not need to implement header logic.
Comprehensive coverage: All API responses—including errors and rate-limiting messages—are automatically secured.
These headers collectively strengthen the browser security boundary, reducing the risk of client-side exploitation while complementing server-side controls such as JWT authentication, refresh token management, and rate limiting.


7. API Gateway: SSL / HTTPS Encryption
To ensure the confidentiality and integrity of data in transit, Streamix implements end-to-end encryption between the client and the API Gateway.
7.1 Encryption Architecture
Secure Sockets Layer (SSL/TLS) is enforced at the Gateway level, protecting sensitive payloads such as authentication tokens, credentials, and user data from interception and Man-in-the-Middle (MitM) attacks.
Keystore Management: For development and local orchestration, the system utilizes a PKCS12 keystore (
keystore.p12). This store contains a self-signed certificate mapped to the streamix-gateway alias, facilitating encrypted communication over the standard secure port 8443.
Encrypted State Propagation: Encryption ensures that once an identity is established, the resulting high-entropy tokens are never transmitted in cleartext, preventing packet sniffing in hostile network environments.
7.2 Microservices Integration
The transition to HTTPS necessitated a comprehensive refactoring of the platform's communication layer:
Standardized Secure Ports: All microservice routes are explicitly configured to bind to secure sockets within the API Gateway (server.port: 8443).
Frontend Service Migration: REST clients in the React frontend (e.g., authService.js, movieService.js) were migrated to use https://localhost:8443 as the base API URL, ensuring compliance with modern browser security contexts.
CORS Preflight (OPTIONS) Optimization: Modern browsers strictly enforce CORS preflight checks during HTTPS state mutations. To prevent false-positives, the 
RateLimiterConfig.java was patched to bypass rate limits for OPTIONS requests, ensuring seamless interaction between the secured frontend and backend.

8. Pentesting 
8.1 Authentication & Authorization Attacks (Testing Auth Flow)
Authentication DoS / Brute Force Mitigation
Objective: To verify that the Distributed API Gateway Rate Limiter can successfully mitigate an asynchronous Denial of Service (DoS) attack targeting the OTP verification endpoint, and to validate the CORS anti-scraping filters.

Attack Execution: Developed and executed an asynchronous Python (aiohttp/asyncio) exploit script (pentest_dos.py). The script circumvented the artificial throttling of common pentesting tools (like Burp Suite Community) to launch 50 mathematically distinct, concurrent POST requests against the /auth/verify endpoint at the exact same millisecond.


Expected Defense:
The API Gateway’s CORS filter should recognize and block non-browser requests (missing Origin or User-Agent headers).
The Redis Token-Bucket algorithm (replenishRate: 10, burstCapacity: 20) should identify the high-frequency traffic originating from the attacker's IP and trigger a localized connection drop when the bucket depletes.

Actual Result: The Gateway functioned perfectly. It intercepted the initial batch of "naked" script requests via the CORS filter, returning HTTP 403 Forbidden. Upon the Redis bucket reaching capacity at request #21, the Gateway triggered its DDoS protection protocol, actively dropping the remaining connections and returning HTTP 429 Too Many Requests.

Status: ✅ Passed

Technical Observation (Non-Sequential Output): Because the Python exploit utilized asyncio to execute all 50 requests concurrently, the Terminal output displayed the HTTP responses arriving asynchronously rather than sequentially (e.g., Request 100044 returning before Request 100009, and 429 interleaving with 403). This is the expected, correct behavior of true asynchronous network routing, where lighter 429 block responses returned faster from the Gateway than the heavier 403 CORS filter evaluations.

Proof of Concept:

Terminal output showing the successful execution and the mixed 403/429 responses

Raw Redis execution logs demonstrating the Token Bucket algorithm actively decrementing available tokens ("19" down to "0") for the attacker's specific IP address (122.170.192.88)
JWT Signature Verification Bypass
Objective: To determine if an attacker can escalate privileges by modifying the payload of a stolen JWT.

Attack Execution: A valid JWT was captured from the browser's Local Storage. Using jwt.io, the token's payload was maliciously modified to impersonate another user account. Because the cryptographic secret (JWT_SECRET) is stored securely on the Render environment, the signature could not be accurately recalculated by the attacker.

Proof of Concept:

Result: The altered token was sent via Postman to the restricted /interaction/watchlist endpoint. The API Gateway successfully intercepted the mathematical discrepancy and rejected the forged token.

Status: ✅ Passed (Vulnerability Mitigated)


Ghost Session Evasion (Max Device Limit)

Objective: Verify the system enforces a strict maximum device limit (5 concurrently) and automatically revokes old, forgotten sessions.

Attack Execution: Simulated a compromised account scenario by generating 6 simultaneous login sessions via Postman. Captured the Refresh Token from the 1st login attempt and attempted to generate a new Access Token using POST /auth/refresh.

Expected Defense: The Redis FIFO Session Queue should identify the 6th login and actively evict/delete the 1st session from the cache to maintain the 5-device limit.

Actual Result: The API Gateway rejected the 1st session's Refresh Token, returning an HTTP 403 Forbidden response indicating the token was successfully invalidated.
 
Attacker session permanently terminated.
Status: ✅ Passed



8.2  Identity Gateway Edge Defense & Access Control Audit
Security Header Audit
Performed a remote header inspection using curl on the production API Gateway.

curl.exe -I https://streamix-api-gateway.onrender.com/auth/login

Key Findings:
HSTS (Strict-Transport-Security): Active (max-age=31536000). Forces browsers to use encrypted HTTPS exclusively.
Anti-Clickjacking: X-Frame-Options: DENY is successfully enforced, preventing the UI from being embedded in malicious iframes.
Content Security Policy (CSP): default-src 'none'; frame-ancestors 'none'; sandbox. A high-security configuration that prevents any script execution at the API level.
Information Leakage Prevention: The Server header returns cloudflare instead of the internal application version (Spring Boot), hiding the technology stack from attackers.
Distributed Rate Limiting (Section 3) is officially working in production.
The remaining: 19 proves that our curl request consumed exactly 1 token from the bucket of 20.
Since this is the Render URL, it proves the Gateway is successfully talking to Upstash Redis in the cloud.


 API Flooding & Denial of Service (DoS)
Objective: Simulate a high-velocity traffic spike to verify the Gateway's ability to protect downstream microservices.
Method: A Python-based multi-threaded script was used to dispatch 60 concurrent GET requests to the endpoint.
Target: https://streamix-api-gateway.onrender.com/auth/login


Findings:
Processed (HTTP 401/403): 26 requests.
Blocked (HTTP 429): 34 requests.
Analysis: The Gateway allowed the initial burst of 20 tokens plus the 6 tokens refilled during the execution window (total 26). Once the bucket was empty, it immediately shifted to a "hard block" state, rejecting the remaining 34 requests.

Conclusion: The Token Bucket algorithm successfully transitioned from "Allow" to "Block" state once the burstCapacity of 20/second was exhausted. This prevents an attacker from overwhelming the Catalog Service or the database.

CORS Preflight (OPTIONS) Logic Verification
Objective: Ensure that the security policy does not interfere with standard browser behavior (CORS Preflight).
Method: Python Script Dispatched 30 consecutive OPTIONS requests to the API Gateway
 The x-ratelimit-remaining header must remain constant or be omitted from the response


Findings:
Success Rate: 100% (30/30 requests returned HTTP 200).
Observation: The x-ratelimit-remaining header was entirely absent from the OPTIONS responses. This confirms that the custom RateLimiterConfig correctly identifies and exempts preflight requests before the rate-limiting logic is even invoked.
Because our "Patch" worked, the Gateway saw the OPTIONS request and skipped the entire Rate Limiting logic.
Since the logic was skipped, the Gateway didn't even bother to add the  to the response.
Conclusion: The fact that the header was missing proves the Gateway successfully "ignored" the request, leaving the tokens 100% safe for actual logins/data.

Status: PASS

8.3  Injection & Unicode ByPass (Testing Input Sanitation & Headers)
SQL Injection (SQLi)
Objective: Test whether the login endpoint is vulnerable to SQL injection via the email or password field.
Tool Used: Browser UI + Terminal (curl)
Payloads Tested:
Password field: ' OR 'x'='x, ' OR 1=1 --, ' OR '1'='1
Email field: ' OR '1'='1' --, ' OR 1=1 --, admin@streamix.com' --
Endpoint Targeted: POST https://streamix-api-gateway.onrender.com/auth/login
Result: Pass — All payloads returned "Invalid credentials" or 401. No unauthorized login occurred, no database errors were leaked to the frontend, and the application remained stable throughout all attempts.
Conclusion: The backend is using parameterized queries via Spring Boot JPA/Hibernate, which neutralizes SQL injection by treating all input as literal string values rather than executable SQL.

Unicode Bypass
Objective: Test whether an invisible Unicode character (U+200E, Left-to-Right Mark) appended to an existing email can bypass the database uniqueness check and create a duplicate account.
Tool Used: Terminal (curl)
Payload Used: charchitsuthar123@gmail.com + invisible \u200E character
Endpoint Targeted: 
POST https://streamix-api-gateway.onrender.com/auth/register
Command Used:
curl -X POST https://streamix-api-gateway.onrender.com/auth/register \
  -H "Content-Type: application/json" \
  -d "{\"fullName\":\"Unicode Test\",\"email\":\"charchitsuthar123@gmail.com\u200E\",\"pass

Response Received:
{"name":"Name is required","email":"Invalid email format"}



8.4 Network & Cloud Misconfigurations (Testing Deployment)
Verification of Zero-Trust Application Firewall
Objective: To verify that the custom Application Firewall successfully intercepts and drops unauthorized requests attempting to bypass the API Gateway.

Test Execution: Executed a direct HTTP POST request against the internal identity-service public URL utilizing a command-line curl client, intentionally omitting the X-Internal-Secret cryptographic header.

Expected Result: The internal microservice should recognize the missing cryptographic stamp and immediately drop the connection without processing the payload.
Actual Result: As demonstrated in the terminal capture, the Spring InternalApiFilter
 successfully intercepted the unauthorized request, immediately returning an HTTP/1.1 403 Forbidden response and preventing direct backend access.

Status: ✅ PASS. 

Cryptographic Transport & SSL Configuration Analysis

Objective: To validate the cryptographic integrity of the API Gateway's external-facing interfaces and ensure robust protection against Man-in-the-Middle (MitM) and SSL-Stripping attacks via independent 3rd-party auditing.

Audit Execution: Conducted an automated cryptographic analysis against the production API Gateway domain utilizing the enterprise-standard Qualys SSL Labs suite. Note that the scanner correctly identified two distinct IP targets as the infrastructure is redundantly load-balanced behind a CDN (Cloudflare).

Findings: The API Gateway topology enforces modern TLS encryption standards, successfully defending against known protocol downgrade vulnerabilities (e.g., POODLE, BEAST).


Conclusion: The robust TLS architecture guarantees that modern web browsers will categorically refuse to negotiate unencrypted connections with the Streamix ecosystem. The comprehensive configuration yielded an overall "A" rating across all analyzed ingress nodes.
Status: ✅ PASS

9. Conclusion
The Streamix security architecture represents a multi-layered approach to protecting a distributed microservices ecosystem. By combining edge-level defenses (SSL/TLS Encryption, Distributed Rate Limiting, and Security Headers), cryptographic hardening (BCrypt, short-lived JWTs), and stateful session orchestration (Redis FIFO queues and server-side invalidation), the platform ensures a secure, resilient, and premium streaming experience.

